-- 성분으로 구분한 아이스크림 총 주문량
SELECT INGREDIENT_TYPE, sum(TOTAL_ORDER) as  TOTAL_ORDER from FIRST_HALF 
inner join ICECREAM_INFO on ICECREAM_INFO.FLAVOR = FIRST_HALF.FLAVOR
group by INGREDIENT_TYPE
order by TOTAL_ORDER


-- 오랜 기간 보호한 동물(1)
SELECT ANIMAL_INS.NAME , ANIMAL_INS.DATETIME FROM ANIMAL_INS
LEFT JOIN ANIMAL_OUTS ON ANIMAL_INS.ANIMAL_ID = ANIMAL_OUTS.ANIMAL_ID 
WHERE ANIMAL_OUTS.DATETIME IS NULL
ORDER BY DATETIME LIMIT 3


-- 있었는데요 없었습니다
SELECT ANIMAL_INS.ANIMAL_ID , ANIMAL_INS.NAME FROM ANIMAL_INS
LEFT JOIN ANIMAL_OUTS ON ANIMAL_INS.ANIMAL_ID = ANIMAL_OUTS.ANIMAL_ID
WHERE ANIMAL_INS.DATETIME > ANIMAL_OUTS.DATETIME 
ORDER BY ANIMAL_INS.DATETIME


-- 오랜 기간 보호한 동물(2)
SELECT ANIMAL_INS.ANIMAL_ID, ANIMAL_INS.NAME FROM ANIMAL_INS
JOIN ANIMAL_OUTS ON ANIMAL_INS.ANIMAL_ID = ANIMAL_OUTS.ANIMAL_ID
ORDER BY DATEDIFF(ANIMAL_OUTS.DATETIME,ANIMAL_INS.DATETIME) DESC LIMIT 2


-- 카테고리 별 도서 판매량 집계하기
SELECT CATEGORY, SUM(BOOK_SALES.SALES) AS TOTAL_SALES FROM BOOK
JOIN BOOK_SALES ON BOOK.BOOK_ID = BOOK_SALES.BOOK_ID
WHERE SALES_DATE LIKE '2022-01%'
GROUP BY CATEGORY
ORDER BY CATEGORY


-- 조건별로 분류하여 주문상태 출력하기
SELECT ORDER_ID, PRODUCT_ID, DATE_FORMAT(OUT_DATE,'%Y-%m-%d') AS OUT_DATE, 
CASE WHEN DATE_FORMAT(OUT_DATE, '%Y-%m-%d') <= '2022-05-01' THEN '출고완료'
    WHEN DATE_FORMAT(OUT_DATE, '%Y-%m-%d') > '2022-05-01' THEN '출고대기'
    WHEN OUT_DATE IS NULL THEN '출고미정' END AS 출고여부
    FROM FOOD_ORDER
    ORDER BY ORDER_ID


-- 조건에 맞는 사용자와 총 거래금액 조회하기
SELECT USER_ID, USED_GOODS_USER.NICKNAME, SUM(PRICE) AS TOTAL_SALES FROM USED_GOODS_BOARD
JOIN USED_GOODS_USER ON USED_GOODS_BOARD.WRITER_ID = USED_GOODS_USER.USER_ID
WHERE STATUS = 'DONE'
GROUP BY USER_ID 
HAVING TOTAL_SALES>=700000
ORDER BY TOTAL_SALES


-- 없어진 기록 찾기
SELECT ANIMAL_OUTS.ANIMAL_ID , ANIMAL_OUTS.NAME FROM ANIMAL_OUTS
LEFT OUTER JOIN ANIMAL_INS ON ANIMAL_INS.ANIMAL_ID = ANIMAL_OUTS.ANIMAL_ID
WHERE ANIMAL_INS.ANIMAL_ID IS NULL 
ORDER BY ANIMAL_INS.ANIMAL_ID, ANIMAL_INS.NAME


-- 즐겨찾기가 가장 많은 식당 정보 출력하기 중요!!!!!!!!!!!!!!!!!!
SELECT FOOD_TYPE, REST_ID, REST_NAME, FAVORITES FROM REST_INFO
WHERE (FOOD_TYPE,FAVORITES) IN (SELECT FOOD_TYPE,MAX(FAVORITES) FROM REST_INFO GROUP BY FOOD_TYPE)
ORDER BY FOOD_TYPE	DESC


-- 조건에 맞는 사용자 정보 조회하기
SELECT DISTINCT(USED_GOODS_USER.USER_ID), USED_GOODS_USER.NICKNAME, CONCAT_WS(" ",USED_GOODS_USER.CITY,USED_GOODS_USER.STREET_ADDRESS1,USED_GOODS_USER.STREET_ADDRESS2) AS '전체주소', CONCAT_WS("-",SUBSTRING(TLNO,1,3),SUBSTRING(TLNO,4,4),SUBSTRING(TLNO,8,4)) AS '전화번호' FROM USED_GOODS_BOARD
JOIN USED_GOODS_USER ON USED_GOODS_BOARD.WRITER_ID = USED_GOODS_USER.USER_ID
WHERE USED_GOODS_USER.USER_ID IN (SELECT WRITER_ID FROM USED_GOODS_BOARD
                                 GROUP BY WRITER_ID	
                                 HAVING COUNT(*)>=3)
ORDER BY USED_GOODS_USER.USER_ID DESC;


-- 헤비 유저가 소유한 장소
SELECT ID, NAME, HOST_ID FROM PLACES
WHERE HOST_ID IN (SELECT HOST_ID FROM PLACES GROUP BY HOST_ID HAVING COUNT(*)>=2)


-- 서울에 위치한 식당 목록 출력하기
SELECT REST_INFO.REST_ID, REST_NAME, FOOD_TYPE, FAVORITES, ADDRESS, ROUND(AVG(REVIEW_SCORE),2) AS SCORE FROM REST_INFO
JOIN REST_REVIEW ON REST_INFO.REST_ID = REST_REVIEW.REST_ID	
GROUP BY REST_ID
HAVING ADDRESS LIKE '서울%'
ORDER BY SCORE DESC, FAVORITES DESC